// è´¦å•æ•°æ®ç®¡ç†æœåŠ¡
import { relationalStore } from '@kit.ArkData'
import { BillRecord, BillType, BillCategory, BillStatistics } from '../model/BillRecord'
import { AccountService } from './AccountService'
import { common } from '@kit.AbilityKit'

@ObservedV2
export class BillService {
  private static instance: BillService
  private rdbStore: relationalStore.RdbStore | null = null
  private context: common.UIAbilityContext | null = null
  private billRecords: BillRecord[] = []
  private categories: BillCategory[] = []
  @Trace private statistics: BillStatistics = new BillStatistics()

  private constructor() {
    this.initDefaultCategories()
  }

  static getInstance(): BillService {
    if (!BillService.instance) {
      BillService.instance = new BillService()
    }
    return BillService.instance
  }

  // åˆå§‹åŒ–æ•°æ®åº“
  async initDatabase(context: common.UIAbilityContext): Promise<void> {
    this.context = context
    const STORE_CONFIG: relationalStore.StoreConfig = {
      name: 'bills.db',
      securityLevel: relationalStore.SecurityLevel.S3
    }

    try {
      this.rdbStore = await relationalStore.getRdbStore(context, STORE_CONFIG)
      await this.createTables()
      await this.loadData()
      // åˆå§‹åŒ–è´¦æˆ·æœåŠ¡
      await AccountService.getInstance().initDatabase(context)
    } catch (error) {
      console.error('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error)
    }
  }

  // åˆ›å»ºæ•°æ®è¡¨
  private async createTables() {
    if (!this.rdbStore) return

    // åˆ›å»ºè´¦å•è®°å½•è¡¨
    const createBillTable = `
      CREATE TABLE IF NOT EXISTS bill_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        amount REAL NOT NULL,
        type TEXT NOT NULL,
        category TEXT NOT NULL,
        note TEXT,
        date TEXT NOT NULL,
        create_time TEXT NOT NULL,
        account_id INTEGER DEFAULT 0
      )
    `

    // åˆ›å»ºåˆ†ç±»è¡¨
    const createCategoryTable = `
      CREATE TABLE IF NOT EXISTS categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        icon TEXT NOT NULL,
        color TEXT DEFAULT '#FF6B6B',
        type TEXT NOT NULL,
        is_default INTEGER DEFAULT 0
      )
    `

    await this.rdbStore.executeSql(createBillTable)
    await this.rdbStore.executeSql(createCategoryTable)
  }

  // åˆå§‹åŒ–é»˜è®¤åˆ†ç±»
  private initDefaultCategories() {
    // æ”¯å‡ºåˆ†ç±»
    this.categories = [
      new BillCategory('é¤é¥®', 'ğŸ½ï¸', BillType.EXPENSE, true, '#FF6B6B'),
      new BillCategory('äº¤é€š', 'ğŸš—', BillType.EXPENSE, true, '#4ECDC4'),
      new BillCategory('è´­ç‰©', 'ğŸ›’', BillType.EXPENSE, true, '#45B7D1'),
      new BillCategory('å¨±ä¹', 'ğŸ®', BillType.EXPENSE, true, '#96CEB4'),
      new BillCategory('åŒ»ç–—', 'ğŸ¥', BillType.EXPENSE, true, '#FFEAA7'),
      new BillCategory('æ•™è‚²', 'ğŸ“š', BillType.EXPENSE, true, '#DDA0DD'),
      new BillCategory('ä½æˆ¿', 'ğŸ ', BillType.EXPENSE, true, '#98D8C8'),
      new BillCategory('å…¶ä»–', 'ğŸ“', BillType.EXPENSE, true, '#F7DC6F'),
      // æ”¶å…¥åˆ†ç±»
      new BillCategory('å·¥èµ„', 'ğŸ’°', BillType.INCOME, true, '#58D68D'),
      new BillCategory('å¥–é‡‘', 'ğŸ', BillType.INCOME, true, '#F8C471'),
      new BillCategory('æŠ•èµ„', 'ğŸ“ˆ', BillType.INCOME, true, '#85C1E9'),
      new BillCategory('å…¼èŒ', 'ğŸ’¼', BillType.INCOME, true, '#BB8FCE'),
      new BillCategory('å…¶ä»–', 'ğŸ“', BillType.INCOME, true, '#82E0AA')
    ]
  }

  // åŠ è½½æ•°æ®
  private async loadData() {
    await this.loadCategories()
    await this.loadBillRecords()
    this.updateStatistics()
  }

  // åŠ è½½è´¦å•è®°å½•
  private async loadBillRecords() {
    if (!this.rdbStore) return

    try {
      const resultSet = await this.rdbStore.querySql('SELECT * FROM bill_records ORDER BY create_time DESC')
      this.billRecords = []
      
      while (resultSet.goToNextRow()) {
        const record = new BillRecord()
        record.id = resultSet.getLong(resultSet.getColumnIndex('id'))
        record.amount = resultSet.getDouble(resultSet.getColumnIndex('amount'))
        record.type = resultSet.getString(resultSet.getColumnIndex('type')) as BillType
        record.category = resultSet.getString(resultSet.getColumnIndex('category'))
        record.note = resultSet.getString(resultSet.getColumnIndex('note'))
        record.date = resultSet.getString(resultSet.getColumnIndex('date'))
        record.createTime = resultSet.getString(resultSet.getColumnIndex('create_time'))
        record.accountId = resultSet.getLong(resultSet.getColumnIndex('account_id'))
        this.billRecords.push(record)
      }
      resultSet.close()
    } catch (error) {
      console.error('åŠ è½½è´¦å•è®°å½•å¤±è´¥:', error)
    }
  }

  // æ·»åŠ è´¦å•è®°å½•
  async addBillRecord(record: BillRecord): Promise<boolean> {
    if (!this.rdbStore) return false

    try {
      const valueBucket: relationalStore.ValuesBucket = {
        amount: record.amount,
        type: record.type,
        category: record.category,
        note: record.note,
        date: record.date,
        create_time: record.createTime,
        account_id: record.accountId
      }

      const rowId = await this.rdbStore.insert('bill_records', valueBucket)
      record.id = rowId
      this.billRecords.unshift(record)
      this.updateStatistics()
      
      // æ›´æ–°è´¦æˆ·ä½™é¢
      const amount = record.type === BillType.INCOME ? record.amount : -record.amount
      await AccountService.getInstance().updateAccountBalance(record.accountId, amount)
      
      // è§¦å‘æ¡Œé¢å¡ç‰‡æ•°æ®åŒæ­¥æ›´æ–°
      await this.notifyWidgetUpdate()
      
      console.info('è´¦å•è®°å½•æ·»åŠ æˆåŠŸï¼Œå·²è§¦å‘æ¡Œé¢å¡ç‰‡æ›´æ–°')
      return true
    } catch (error) {
      console.error('æ·»åŠ è´¦å•è®°å½•å¤±è´¥:', error)
      return false
    }
  }

  // è·å–è´¦å•è®°å½•åˆ—è¡¨
  getBillRecords(): BillRecord[] {
    return this.billRecords
  }

  // è·å–æœ€è¿‘çš„è´¦å•è®°å½•
  getRecentBillRecords(limit: number = 5): BillRecord[] {
    return this.billRecords.slice(0, limit)
  }

  // è·å–åˆ†ç±»åˆ—è¡¨
  getCategories(type?: BillType): BillCategory[] {
    if (type) {
      return this.categories.filter(category => category.type === type)
    }
    return this.categories
  }

  // è·å–æ‰€æœ‰åˆ†ç±»åç§°
  async getAllCategories(): Promise<string[]> {
    const categories = this.getCategories()
    return categories.map(category => category.name)
  }

  // åŠ è½½åˆ†ç±»æ•°æ®
  private async loadCategories() {
    if (!this.rdbStore) return

    try {
      const resultSet = await this.rdbStore.querySql('SELECT * FROM categories ORDER BY type, name')
      const loadedCategories: BillCategory[] = []
      
      while (resultSet.goToNextRow()) {
        const category = new BillCategory('', '', BillType.EXPENSE)
        category.id = resultSet.getLong(resultSet.getColumnIndex('id'))
        category.name = resultSet.getString(resultSet.getColumnIndex('name'))
        category.icon = resultSet.getString(resultSet.getColumnIndex('icon'))
        category.color = resultSet.getString(resultSet.getColumnIndex('color')) || '#FF6B6B'
        category.type = resultSet.getString(resultSet.getColumnIndex('type')) as BillType
        category.isDefault = resultSet.getLong(resultSet.getColumnIndex('is_default')) === 1
        loadedCategories.push(category)
      }
      resultSet.close()
      
      // å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰åˆ†ç±»ï¼Œåˆ™æ’å…¥é»˜è®¤åˆ†ç±»
      if (loadedCategories.length === 0) {
        await this.insertDefaultCategories()
      } else {
        this.categories = loadedCategories
      }
    } catch (error) {
      console.error('åŠ è½½åˆ†ç±»æ•°æ®å¤±è´¥:', error)
      // å¦‚æœåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤åˆ†ç±»
      await this.insertDefaultCategories()
    }
  }

  // æ’å…¥é»˜è®¤åˆ†ç±»åˆ°æ•°æ®åº“
  private async insertDefaultCategories() {
    if (!this.rdbStore) return

    try {
      for (const category of this.categories) {
        const valueBucket: relationalStore.ValuesBucket = {
          name: category.name,
          icon: category.icon,
          color: category.color,
          type: category.type,
          is_default: category.isDefault ? 1 : 0
        }
        const rowId = await this.rdbStore.insert('categories', valueBucket)
        category.id = rowId
      }
    } catch (error) {
      console.error('æ’å…¥é»˜è®¤åˆ†ç±»å¤±è´¥:', error)
    }
  }

  // æ·»åŠ è‡ªå®šä¹‰åˆ†ç±»
  async addCategory(category: BillCategory): Promise<boolean> {
    if (!this.rdbStore) return false

    try {
      const valueBucket: relationalStore.ValuesBucket = {
        name: category.name,
        icon: category.icon,
        color: category.color,
        type: category.type,
        is_default: 0
      }
      
      const rowId = await this.rdbStore.insert('categories', valueBucket)
      category.id = rowId
      this.categories.push(category)
      return true
    } catch (error) {
      console.error('æ·»åŠ åˆ†ç±»å¤±è´¥:', error)
      return false
    }
  }

  // æ›´æ–°åˆ†ç±»
  async updateCategory(category: BillCategory): Promise<boolean> {
    if (!this.rdbStore || category.id === 0) return false

    try {
      const valueBucket: relationalStore.ValuesBucket = {
        name: category.name,
        icon: category.icon,
        color: category.color,
        type: category.type
      }
      
      const predicates = new relationalStore.RdbPredicates('categories')
      predicates.equalTo('id', category.id)
      
      const rowsAffected = await this.rdbStore.update(valueBucket, predicates)
      if (rowsAffected > 0) {
        // æ›´æ–°å†…å­˜ä¸­çš„åˆ†ç±»
        const index = this.categories.findIndex(c => c.id === category.id)
        if (index !== -1) {
          this.categories[index] = category
        }
        return true
      }
      return false
    } catch (error) {
      console.error('æ›´æ–°åˆ†ç±»å¤±è´¥:', error)
      return false
    }
  }

  // åˆ é™¤åˆ†ç±»
  async deleteCategory(categoryId: number): Promise<boolean> {
    if (!this.rdbStore || categoryId === 0) return false

    try {
      // æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤åˆ†ç±»
      const category = this.categories.find(c => c.id === categoryId)
      if (category?.isDefault) {
        console.warn('ä¸èƒ½åˆ é™¤é»˜è®¤åˆ†ç±»')
        return false
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰å…³è”çš„è´¦å•è®°å½•
      const hasRecords = this.billRecords.some(record => {
        const recordCategory = this.categories.find(c => c.name === record.category)
        return recordCategory?.id === categoryId
      })
      
      if (hasRecords) {
        console.warn('è¯¥åˆ†ç±»ä¸‹æœ‰è´¦å•è®°å½•ï¼Œä¸èƒ½åˆ é™¤')
        return false
      }

      const predicates = new relationalStore.RdbPredicates('categories')
      predicates.equalTo('id', categoryId)
      
      const rowsAffected = await this.rdbStore.delete(predicates)
      if (rowsAffected > 0) {
        // ä»å†…å­˜ä¸­ç§»é™¤åˆ†ç±»
        this.categories = this.categories.filter(c => c.id !== categoryId)
        return true
      }
      return false
    } catch (error) {
      console.error('åˆ é™¤åˆ†ç±»å¤±è´¥:', error)
      return false
    }
  }

  // è·å–æœˆåº¦æ”¯å‡ºæ€»é¢
  async getMonthlyExpense(year: number, month: number): Promise<number> {
    const records = this.billRecords.filter(record => {
      const recordDate = new Date(record.date)
      return record.type === BillType.EXPENSE &&
             recordDate.getFullYear() === year &&
             recordDate.getMonth() + 1 === month
    })
    return records.reduce((sum, record) => sum + record.amount, 0)
  }

  // è·å–åˆ†ç±»æ”¯å‡ºé‡‘é¢
  async getCategoryExpense(category: string, year: number, month: number): Promise<number> {
    const records = this.billRecords.filter(record => {
      const recordDate = new Date(record.date)
      return record.type === BillType.EXPENSE &&
             record.category === category &&
             recordDate.getFullYear() === year &&
             recordDate.getMonth() + 1 === month
    })
    return records.reduce((sum, record) => sum + record.amount, 0)
  }

  // è·å–ç»Ÿè®¡æ•°æ®
  getStatistics(): BillStatistics {
    return this.statistics
  }

  // æ›´æ–°ç»Ÿè®¡æ•°æ®
  private updateStatistics() {
    const currentMonth = new Date().toISOString().slice(0, 7) // YYYY-MM
    
    this.statistics.totalIncome = this.billRecords
      .filter(record => record.type === BillType.INCOME)
      .reduce((sum, record) => sum + record.amount, 0)
    
    this.statistics.totalExpense = this.billRecords
      .filter(record => record.type === BillType.EXPENSE)
      .reduce((sum, record) => sum + record.amount, 0)
    
    this.statistics.monthlyIncome = this.billRecords
      .filter(record => record.type === BillType.INCOME && record.date.startsWith(currentMonth))
      .reduce((sum, record) => sum + record.amount, 0)
    
    this.statistics.monthlyExpense = this.billRecords
      .filter(record => record.type === BillType.EXPENSE && record.date.startsWith(currentMonth))
      .reduce((sum, record) => sum + record.amount, 0)
    
    this.statistics.updateBalance()
  }

  // æ ¼å¼åŒ–é‡‘é¢æ˜¾ç¤º
  static formatAmount(amount: number): string {
    return amount.toFixed(2)
  }

  // é€šçŸ¥æ¡Œé¢å¡ç‰‡æ›´æ–°
  private async notifyWidgetUpdate(): Promise<void> {
    try {
      // å¯¼å…¥WidgetServiceå¹¶è§¦å‘æ›´æ–°
      const widgetServiceModule = await import('../service/WidgetService')
      const widgetService = widgetServiceModule.WidgetService.getInstance()
      
      // æ›´æ–°æ‰€æœ‰æ´»è·ƒçš„æ¡Œé¢å¡ç‰‡
      await widgetService.updateAllActiveWidgets()
      
      console.info('æ¡Œé¢å¡ç‰‡æ•°æ®åŒæ­¥æ›´æ–°å®Œæˆ')
    } catch (error) {
      console.error('æ¡Œé¢å¡ç‰‡æ›´æ–°å¤±è´¥:', error)
    }
  }
}