import { preferences } from '@kit.ArkData'
import { notificationManager } from '@kit.NotificationKit'
import { wantAgent, WantAgent } from '@kit.AbilityKit'

/**
 * æé†’ç±»å‹
 */
export enum ReminderType {
  DAILY = 'daily',
  WEEKLY = 'weekly',
  MONTHLY = 'monthly'
}

/**
 * æé†’é…ç½®
 */
export interface ReminderConfig {
  id?: number
  type: ReminderType
  hour: number
  minute: number
  title: string
  content: string
  enabled: boolean
  repeatDays?: number[] // å‘¨å‡ æé†’ï¼Œ1-7è¡¨ç¤ºå‘¨ä¸€åˆ°å‘¨æ—¥
}

/**
 * å®šæ—¶æé†’æœåŠ¡
 */
export class ReminderService {
  private static instance: ReminderService
  private readonly REMINDER_PREFS_KEY = 'reminder_settings'
  private dataPreferences: preferences.Preferences | null = null

  private constructor() {
    this.initPreferences()
  }

  public static getInstance(): ReminderService {
    if (!ReminderService.instance) {
      ReminderService.instance = new ReminderService()
    }
    return ReminderService.instance
  }

  // åˆå§‹åŒ–æ•°æ®å­˜å‚¨
  private async initPreferences(): Promise<void> {
    try {
      this.dataPreferences = await preferences.getPreferences(getContext(), 'reminder_prefs')
    } catch (error) {
      console.error('Failed to init reminder preferences:', error)
    }
  }

  // è·å–æ‰€æœ‰æé†’é…ç½®
  public async getAllReminders(): Promise<ReminderConfig[]> {
    try {
      if (!this.dataPreferences) {
        await this.initPreferences()
      }
      
      const remindersJson = await this.dataPreferences?.get(this.REMINDER_PREFS_KEY, '[]') as string
      return JSON.parse(remindersJson) as ReminderConfig[]
    } catch (error) {
      console.error('Failed to get reminders:', error)
      return []
    }
  }

  // ä¿å­˜æé†’é…ç½®
  private async saveReminders(reminders: ReminderConfig[]): Promise<boolean> {
    try {
      if (!this.dataPreferences) {
        await this.initPreferences()
      }
      
      await this.dataPreferences?.put(this.REMINDER_PREFS_KEY, JSON.stringify(reminders))
      await this.dataPreferences?.flush()
      return true
    } catch (error) {
      console.error('Failed to save reminders:', error)
      return false
    }
  }

  // æ·»åŠ æé†’
  public async addReminder(config: ReminderConfig): Promise<boolean> {
    try {
      const reminders = await this.getAllReminders()
      
      // ç”Ÿæˆæ–°çš„ID
      const newId = Date.now()
      config.id = newId
      
      reminders.push(config)
      
      const saved = await this.saveReminders(reminders)
      if (saved && config.enabled) {
        await this.scheduleReminder(config)
      }
      
      return saved
    } catch (error) {
      console.error('Failed to add reminder:', error)
      return false
    }
  }

  // æ›´æ–°æé†’
  public async updateReminder(config: ReminderConfig): Promise<boolean> {
    try {
      const reminders = await this.getAllReminders()
      const index = reminders.findIndex(r => r.id === config.id)
      
      if (index === -1) {
        return false
      }
      
      // å…ˆå–æ¶ˆæ—§çš„æé†’
      if (reminders[index].enabled && reminders[index].id) {
        await this.cancelReminder(reminders[index].id!)
      }
      
      reminders[index] = config
      
      const saved = await this.saveReminders(reminders)
      if (saved && config.enabled && config.id) {
        await this.scheduleReminder(config)
      }
      
      return saved
    } catch (error) {
      console.error('Failed to update reminder:', error)
      return false
    }
  }

  // åˆ é™¤æé†’
  public async deleteReminder(id: number): Promise<boolean> {
    try {
      const reminders = await this.getAllReminders()
      const index = reminders.findIndex(r => r.id === id)
      
      if (index === -1) {
        return false
      }
      
      // å–æ¶ˆç³»ç»Ÿæé†’
      await this.cancelReminder(id)
      
      reminders.splice(index, 1)
      return await this.saveReminders(reminders)
    } catch (error) {
      console.error('Failed to delete reminder:', error)
      return false
    }
  }

  // å¯ç”¨/ç¦ç”¨æé†’
  public async toggleReminder(id: number, enabled: boolean): Promise<boolean> {
    try {
      const reminders = await this.getAllReminders()
      const reminder = reminders.find(r => r.id === id)
      
      if (!reminder) {
        return false
      }
      
      reminder.enabled = enabled
      
      if (enabled) {
        await this.scheduleReminder(reminder)
      } else {
        await this.cancelReminder(id)
      }
      
      return await this.saveReminders(reminders)
    } catch (error) {
      console.error('Failed to toggle reminder:', error)
      return false
    }
  }

  // è°ƒåº¦ç³»ç»Ÿæé†’
  private async scheduleReminder(config: ReminderConfig): Promise<void> {
    try {
      if (!config.id) {
        console.error('Reminder config must have an id')
        return
      }

      // åˆ›å»ºWantAgentç”¨äºç‚¹å‡»é€šçŸ¥æ—¶çš„è¡Œä¸º
      const wantAgentInfo: wantAgent.WantAgentInfo = {
        wants: [
          {
            bundleName: 'com.example.accountingbook3',
            abilityName: 'EntryAbility'
          }
        ],
        operationType: wantAgent.OperationType.START_ABILITY,
        requestCode: config.id || 0
      }

      const wantAgentObj: WantAgent = await wantAgent.getWantAgent(wantAgentInfo)

      // æ„å»ºé€šçŸ¥è¯·æ±‚
      const notificationRequest: notificationManager.NotificationRequest = {
        id: config.id || 0,
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: config.title,
            text: config.content
          }
        },
        wantAgent: wantAgentObj
      }

      // å‘å¸ƒé€šçŸ¥ï¼ˆè¿™é‡Œåªæ˜¯ç¤ºä¾‹ï¼Œå®é™…çš„å®šæ—¶åŠŸèƒ½éœ€è¦é…åˆç³»ç»Ÿå®šæ—¶å™¨ï¼‰
      console.log(`Reminder scheduled successfully for ${config.hour}:${config.minute}`)
      console.log('Note: Actual scheduling requires system timer integration')
    } catch (error) {
      console.error('Failed to schedule reminder:', error)
    }
  }

  // å–æ¶ˆç³»ç»Ÿæé†’
  private async cancelReminder(id: number): Promise<void> {
    try {
      // å–æ¶ˆé€šçŸ¥
      await notificationManager.cancel(id)
      console.log(`Reminder ${id} cancelled successfully`)
    } catch (error) {
      console.error('Failed to cancel reminder:', error)
    }
  }

  // è·å–é»˜è®¤æé†’é…ç½®
  public getDefaultReminders(): ReminderConfig[] {
    return [
      {
        type: ReminderType.DAILY,
        hour: 21,
        minute: 0,
        title: 'ğŸ» è®°è´¦æé†’',
        content: 'ä»Šå¤©è¿˜æ²¡æœ‰è®°è´¦å“¦ï¼Œå¿«æ¥è®°å½•ä¸€ä¸‹ä»Šå¤©çš„æ”¶æ”¯å§ï¼',
        enabled: false
      },
      {
        type: ReminderType.WEEKLY,
        hour: 20,
        minute: 0,
        title: 'ğŸ» å‘¨æ€»ç»“æé†’',
        content: 'æœ¬å‘¨çš„è´¦å•è®°å½•å¾—æ€ä¹ˆæ ·ï¼Ÿæ¥çœ‹çœ‹è¿™å‘¨çš„æ”¶æ”¯æƒ…å†µå§ï¼',
        enabled: false,
        repeatDays: [7] // å‘¨æ—¥
      }
    ]
  }

  // åˆå§‹åŒ–é»˜è®¤æé†’
  public async initDefaultReminders(): Promise<void> {
    try {
      const existingReminders = await this.getAllReminders()
      if (existingReminders.length === 0) {
        const defaultReminders = this.getDefaultReminders()
        for (const reminder of defaultReminders) {
          await this.addReminder(reminder)
        }
      }
    } catch (error) {
      console.error('Failed to init default reminders:', error)
    }
  }

  // æ£€æŸ¥æé†’æƒé™
  public async checkReminderPermission(): Promise<boolean> {
    try {
      // è¿™é‡Œå¯ä»¥æ·»åŠ æƒé™æ£€æŸ¥é€»è¾‘
      return true
    } catch (error) {
      console.error('Failed to check reminder permission:', error)
      return false
    }
  }

  // è¯·æ±‚æé†’æƒé™
  public async requestReminderPermission(): Promise<boolean> {
    try {
      // è¿™é‡Œå¯ä»¥æ·»åŠ æƒé™è¯·æ±‚é€»è¾‘
      return true
    } catch (error) {
      console.error('Failed to request reminder permission:', error)
      return false
    }
  }

  // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
  public formatTime(hour: number, minute: number): string {
    const h = hour.toString().padStart(2, '0')
    const m = minute.toString().padStart(2, '0')
    return `${h}:${m}`
  }

  // æ ¼å¼åŒ–é‡å¤å¤©æ•°æ˜¾ç¤º
  public formatRepeatDays(days: number[]): string {
    if (!days || days.length === 0) {
      return 'ä¸é‡å¤'
    }
    
    if (days.length === 7) {
      return 'æ¯å¤©'
    }
    
    const dayNames = ['', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­', 'å‘¨æ—¥']
    return days.map(day => dayNames[day]).join('ã€')
  }

  // è·å–ä¸‹æ¬¡æé†’æ—¶é—´
  public getNextReminderTime(config: ReminderConfig): Date | null {
    try {
      const now = new Date()
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), config.hour, config.minute)
      
      if (config.type === ReminderType.DAILY) {
        if (today > now) {
          return today
        } else {
          const tomorrow = new Date(today)
          tomorrow.setDate(tomorrow.getDate() + 1)
          return tomorrow
        }
      }
      
      if (config.type === ReminderType.WEEKLY && config.repeatDays) {
        const currentDay = now.getDay() || 7 // å°†å‘¨æ—¥ä»0æ”¹ä¸º7
        
        for (const day of config.repeatDays.sort()) {
          if (day > currentDay || (day === currentDay && today > now)) {
            const nextDate = new Date(today)
            nextDate.setDate(nextDate.getDate() + (day - currentDay))
            return nextDate
          }
        }
        
        // ä¸‹å‘¨çš„ç¬¬ä¸€ä¸ªæé†’æ—¥
        const firstDay = config.repeatDays[0]
        const nextWeek = new Date(today)
        nextWeek.setDate(nextWeek.getDate() + (7 - currentDay + firstDay))
        return nextWeek
      }
      
      return null
    } catch (error) {
      console.error('Failed to get next reminder time:', error)
      return null
    }
  }
}